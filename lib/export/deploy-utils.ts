import { GeneratedComponent } from "@/types/generated-component";
import { getDeploymentDependencies } from "@/lib/preview/sandbox";
import sdk from "@stackblitz/sdk";
import LZString from "lz-string";

type ToastFunction = (message: string, type: 'success' | 'error' | 'info') => void;

function generateProjectFiles(component: GeneratedComponent) {
    const deps = getDeploymentDependencies();

    // Package.json - Vite configuration
    const packageJson = {
        name: component.name.toLowerCase().replace(/\s+/g, '-'),
        version: "1.0.0",
        description: component.description || "Generated by EcomCoder",
        type: "module",
        scripts: {
            "dev": "vite",
            "build": "tsc && vite build",
            "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
            "preview": "vite preview"
        },
        dependencies: deps.dependencies,
        devDependencies: deps.devDependencies
    };

    // tailwind.config.js
    const tailwindConfig = `/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}`;

    // vite.config.ts
    const viteConfig = `import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
})`;

    // index.html (Root level for Vite)
    const indexHtml = `<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>${component.name}</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>`;

    // src/main.tsx
    const mainTsx = `import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)`;

    // src/index.css
    const indexCss = `@tailwind base;
@tailwind components;
@tailwind utilities;

body {
    background-color: #000;
    color: #fff;
}`;

    // src/App.tsx
    const appTsx = component.code;

    // tsconfig.json
    const tsConfig = {
        "compilerOptions": {
            "target": "ES2020",
            "useDefineForClassFields": true,
            "lib": ["ES2020", "DOM", "DOM.Iterable"],
            "module": "ESNext",
            "skipLibCheck": true,
            "moduleResolution": "bundler",
            "allowImportingTsExtensions": true,
            "resolveJsonModule": true,
            "isolatedModules": true,
            "noEmit": true,
            "jsx": "react-jsx",
            "strict": true,
            "noUnusedLocals": true,
            "noUnusedParameters": true,
            "noFallthroughCasesInSwitch": true
        },
        "include": ["src"],
        "references": [{ "path": "./tsconfig.node.json" }]
    };

    // tsconfig.node.json
    const tsConfigNode = {
        "compilerOptions": {
            "composite": true,
            "skipLibCheck": true,
            "module": "ESNext",
            "moduleResolution": "bundler",
            "allowSyntheticDefaultImports": true
        },
        "include": ["vite.config.ts"]
    };

    // postcss.config.js
    const postcssConfig = `export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}`;

    return {
        "package.json": JSON.stringify(packageJson, null, 2),
        "vite.config.ts": viteConfig,
        "tailwind.config.js": tailwindConfig,
        "postcss.config.js": postcssConfig,
        "index.html": indexHtml,
        "src/main.tsx": mainTsx,
        "src/index.css": indexCss,
        "src/App.tsx": appTsx,
        "tsconfig.json": JSON.stringify(tsConfig, null, 2),
        "tsconfig.node.json": JSON.stringify(tsConfigNode, null, 2)
    };
}

function compressParameters(parameters: any) {
    return LZString.compressToBase64(JSON.stringify(parameters))
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/, '');
}

export async function deployToCodeSandbox(component: GeneratedComponent, toast: ToastFunction) {
    try {
        const files = generateProjectFiles(component);

        // CodeSandbox Define API mapping for Vite structure
        const parameters = {
            files: {
                "package.json": { content: files["package.json"] },
                "vite.config.ts": { content: files["vite.config.ts"] },
                "tailwind.config.js": { content: files["tailwind.config.js"] },
                "postcss.config.js": { content: files["postcss.config.js"] },
                "index.html": { content: files["index.html"] },
                "src/main.tsx": { content: files["src/main.tsx"] },
                "src/index.css": { content: files["src/index.css"] },
                "src/App.tsx": { content: files["src/App.tsx"] },
                "tsconfig.json": { content: files["tsconfig.json"] },
                "tsconfig.node.json": { content: files["tsconfig.node.json"] }
            }
        };

        const compressedParameters = compressParameters(parameters);

        const response = await fetch("https://codesandbox.io/api/v1/sandboxes/define?json=1", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            body: JSON.stringify({ parameters: compressedParameters })
        });

        if (!response.ok) {
            throw new Error(`Failed to create sandbox: ${response.statusText}`);
        }

        const data = await response.json();
        const sandboxId = data.sandbox_id;

        if (sandboxId) {
            window.open(`https://codesandbox.io/s/${sandboxId}`, "_blank");
            toast("Deployed to CodeSandbox!", "success");
        } else {
            throw new Error("No sandbox ID received");
        }

    } catch (error) {
        console.error("CodeSandbox deployment error:", error);
        toast("Failed to deploy to CodeSandbox", "error");
    }
}

export async function deployToStackBlitz(component: GeneratedComponent, toast: ToastFunction) {
    try {
        const files = generateProjectFiles(component);

        await sdk.openProject({
            title: component.name,
            description: component.description || "Generated by EcomCoder",
            template: "node",
            files: files
        }, {
            newWindow: true,
            openFile: 'src/App.tsx'
        });

        toast("Deployed to StackBlitz!", "success");
    } catch (error) {
        console.error("StackBlitz deployment error:", error);
        toast("Failed to deploy to StackBlitz", "error");
    }
}
