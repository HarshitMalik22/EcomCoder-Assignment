import Anthropic from '@anthropic-ai/sdk';
import { AnthropicBedrock } from '@anthropic-ai/bedrock-sdk';
import OpenAI from 'openai';
import { GenerationRequest, GeneratedComponent } from '@/types/generated-component';
import { SYSTEM_PROMPT, generateUserPrompt } from './prompts';
import { parseGeneratedCode } from './parser';

export async function generateComponent(request: GenerationRequest): Promise<GeneratedComponent> {
    const { sectionData, model = 'claude' } = request;

    if ((process.env.ANTHROPIC_API_KEY || process.env.AWS_ACCESS_KEY_ID) && model === 'claude') {
        return generateWithClaude(request);
    } else if (process.env.OPENAI_API_KEY) {
        return generateWithOpenAI(request);
    } else {
        throw new Error("No API keys found for Anthropic (API Key or AWS Bedrock) or OpenAI");
    }
}

async function generateWithClaude(request: GenerationRequest): Promise<GeneratedComponent> {
    let anthropic: any;

    const apiKey = process.env.ANTHROPIC_API_KEY || '';

    if (apiKey.startsWith('ABSK')) {
        // Decode custom Bedrock key
        try {
            const decoded = Buffer.from(apiKey.substring(4), 'base64').toString();
            const [accessKey, secretKey] = decoded.split(':');

            anthropic = new AnthropicBedrock({
                awsAccessKey: accessKey,
                awsSecretKey: secretKey,
                awsRegion: process.env.AWS_REGION || 'us-east-1',
            });
        } catch (e) {
            console.error("Failed to decode custom Bedrock key", e);
            throw new Error("Invalid custom Bedrock key format");
        }
    } else if (process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY) {
        anthropic = new AnthropicBedrock({
            awsAccessKey: process.env.AWS_ACCESS_KEY_ID,
            awsSecretKey: process.env.AWS_SECRET_ACCESS_KEY,
            awsRegion: process.env.AWS_REGION || 'us-east-1',
        });
    } else {
        anthropic = new Anthropic({
            apiKey: apiKey,
            baseURL: process.env.ANTHROPIC_BASE_URL
        });
    }

    const { sectionData, customPrompt } = request;

    const userContent: any[] = [
        {
            type: 'text',
            text: customPrompt || generateUserPrompt(sectionData.type, sectionData.html, sectionData.images)
        }
    ];

    if (sectionData.screenshot) {
        userContent.push({
            type: 'image',
            source: {
                type: 'base64',
                media_type: 'image/jpeg',
                data: sectionData.screenshot,
            },
        });
    }

    const isBedrock = apiKey.startsWith('ABSK') || !!process.env.AWS_ACCESS_KEY_ID;
    // Use Claude 3.5 Sonnet as the default high-performance model
    const modelId = isBedrock ? 'anthropic.claude-3-5-sonnet-20240620-v1:0' : 'claude-3-5-sonnet-20240620';

    const msg = await anthropic.messages.create({
        model: modelId,
        max_tokens: 4096,
        system: SYSTEM_PROMPT,
        messages: [
            {
                role: 'user',
                content: userContent,
            },
        ],
    });

    // Handle TextBlock
    const textContent = msg.content.find((c: any) => c.type === 'text');
    const rawCode = textContent && 'text' in textContent ? textContent.text : '';
    const code = parseGeneratedCode(rawCode);

    return {
        id: sectionData.id,
        name: `${sectionData.type.charAt(0).toUpperCase() + sectionData.type.slice(1)}Component`,
        code,
        description: "Generated by Claude 3.5 Sonnet",
    };
}

async function generateWithOpenAI(request: GenerationRequest): Promise<GeneratedComponent> {
    const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
    const { sectionData, customPrompt } = request;

    const messages: any[] = [
        { role: "system", content: SYSTEM_PROMPT },
        {
            role: "user",
            content: [
                { type: "text", text: customPrompt || generateUserPrompt(sectionData.type, sectionData.html, sectionData.images) }
            ]
        }
    ];

    if (sectionData.screenshot) {
        messages[1].content.push({
            type: "image_url",
            image_url: {
                url: `data:image/jpeg;base64,${sectionData.screenshot}`,
            },
        });
    }

    const response = await openai.chat.completions.create({
        model: "gpt-4o",
        messages: messages,
        max_tokens: 4000,
    });

    const rawCode = response.choices[0].message.content || '';
    const code = parseGeneratedCode(rawCode);

    return {
        id: sectionData.id,
        name: `${sectionData.type.charAt(0).toUpperCase() + sectionData.type.slice(1)}Component`,
        code,
        description: "Generated by GPT-4o",
    };
}
